#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Music Player Daemon Frontend. Adds a head to headless MPD.
"""

import sys, re, time, os, html, io, signal
import argparse
import logging
import threading
import configparser
import PIL
from PIL import Image
import musicpd
import mutagen
from mutagen.id3 import ID3, APIC
from mutagen.flac import FLAC
from mutagen.dsf import DSF
from mutagen.mp4 import MP4
import gi

gi.require_version("Gtk", "4.0")
from gi.repository import Gtk, Gdk, GdkPixbuf, GObject, Pango, GLib

def signal_exit(sig, frame):
    """
    Perform a clean exit.
    """
    Defaults.get_logger().debug("caught signal %s, exiting" % signal.Signals(sig).name)
    sys.exit(0)

class Defaults:
    application_id = "com.github.randohm.mpdfront"
    log = None
    log_format = "%(asctime)s %(levelname)s %(module)s::%(funcName)s(%(lineno)d): %(message)s"
    config_file = os.environ['HOME'] + "/.config/mpdfront/mpdfront.cfg"
    idle_sleep_retry_connect = 2

    @staticmethod
    def init_logger():
        """
        Create and initialize logger object
        :return: None
        """
        log = logging.getLogger("mpdfront")
        log.setLevel(logging.INFO)
        formatter = logging.Formatter(Defaults.log_format)
        handler = logging.StreamHandler(sys.stdout)
        handler.setFormatter(formatter)
        log.addHandler(handler)
        Defaults.log = log

    @staticmethod
    def get_logger():
        """
        Returns the logging object
        :return: logging object
        """
        return Defaults.log

class Constants:
    ## symbols for playback control button labels
    symbol_previous = chr(9612) + chr(9664)
    symbol_rewind = chr(9664) + chr(9664)
    symbol_stop = chr(9608)
    symbol_play = chr(9613) + chr(9654)
    symbol_pause = chr(9613) + chr(9613)
    symbol_cue = chr(9654) + chr(9654)
    symbol_next = chr(9654) + " " + chr(9612)

    ## Key codes
    keyval_play = 0x1008ff14
    keyval_rewind = 0x1008ff3e
    keyval_cue = 0x1008ff97
    keyval_previous = 0x1008ff16
    keyval_next = 0x1008ff17

    ## Rows for 1st column of browser
    browser_1st_column_rows = [
        {'type': 'category', 'value': 'Album Artists', 'data': None},
        {'type': 'category', 'value': 'Artists', 'data': None},
        {'type': 'category', 'value': 'Albums', 'data': None},
        {'type': 'category', 'value': 'Files', 'data': None},
        {'type': 'category', 'value': 'Genres', 'data': None},
    ]

    proc_file_fmt = "/proc/asound/card%s/pcm%sp/sub%s/hw_params"  ## proc file with DAC information

def listbox_cmp(row1, row2, data, notify_destroy):
    """
    Compare function for Gtk.ListBox sorting. Does a simple string cmp on the rows' text
    Args:
        Standard args for Gtk.ListBox sort compare function.
    """
    return row1.get_child().get_text() > row2.get_child().get_text()

def listbox_cmp_filtered(row1, row2, data, notify_destroy):
    """
    Compare function for Gtk.ListBox sorting. Modifies the text before comparison.
    Removes from text: /^The /
    Args:
        Standard args for Gtk.ListBox sort compare function.
    """
    row1_value = re.sub(r'^The ', '', row1.get_child().get_text(), flags=re.IGNORECASE)
    row2_value = re.sub(r'^The ', '', row2.get_child().get_text(), flags=re.IGNORECASE)

    return row1_value > row2_value

def listbox_cmp_by_track(row1, row2, data, notify_destroy):
    """
    Compare function for Gtk.ListBox sorting. Modifies the text before comparison.
    Args:
        Standard args for Gtk.ListBox sort compare function.
    """
    if not ('track' in row1.get_child().data['track'] and 'track' in row2.get_child().data['track']):
        return 0
    row1_value = int(row1.get_child().data['track'])
    row2_value = int(row2.get_child().data['track'])

    return row1_value > row2_value

def pp_time(secs):
    """
    Pretty-print time convenience function. Takes a count of seconds and formats to MM:SS.

    Args:
        secs: int of number of seconds

    Returns:
        string with the time in the format of MM:SS
    """
    return "%d:%02d" % (int(int(secs) / 60), int(secs) % 60)

class SongInfoDialog(Gtk.AlertDialog):
    """
    Shows a MessageDialog with song tags and information.
    Click OK to exit.
    """

    def __init__(self, parent, song, *args, **kwargs):
        """
        Build markup text to display, display markup text
        """
        self.log = Defaults.get_logger()
        super().__init__(*args, **kwargs)
        self.set_modal(True)
        message = ""
        detail = ""
        if 'title' in song:
            message = song['title']
        if 'artist' in song:
            detail += "Artist: %s\n" % song['artist']
        if 'album' in song:
            detail += "Album: %s\n" % song['album']
        if 'time' in song:
            detail += "Time: %s\n" % pp_time(song['time'])
        if 'track' in song:
            detail += "Track: %s\n" % song['track']
        if 'date' in song:
            detail += "Date: %s\n" % song['date']
        if 'genre' in song:
            detail += "Genre: %s\n" % song['genre']

        if message == "":
            message = "File: %s" % song['file']
        else:
            detail += "File: %s" % song['file']

        self.set_message(message)
        self.set_detail(detail)
        self.choose(parent=parent, cancellable=None, callback=None)

class CardSelectDialog(Gtk.Dialog):
    """
    Display dialog to select sound card and device IDs.
    Button click events are handled by a callback function passed to __init__.
    """

    def __init__(self, parent, button_pressed_callback, *args, **kwargs):
        """
        Args:
            parent: parent window
            button_pressed_callback: callback function handling spinbutton change events.
                                     callback accepts +1 args for the type of change.
        """
        self.log = Defaults.get_logger()
        super().__init__(title="Select Sound Card", parent=parent, *args, **kwargs)
        self.set_modal(True)
        self.add_button("Close", 0)
        self.set_name("cardselect-dialog")
        self.get_content_area().set_size_request(300, 200)

        card_id_button = Gtk.SpinButton.new_with_range(0, 4, 1)
        card_id_button.set_name("card_id")
        card_id_button.set_numeric(True)
        card_id_button.set_value(parent.card_id)
        card_id_label = Gtk.Label(label="Card ID")
        card_id_button.connect("value-changed", button_pressed_callback, "card_id")

        device_id_button = Gtk.SpinButton.new_with_range(0, 4, 1)
        device_id_button.set_name("device_id")
        device_id_button.set_numeric(True)
        device_id_button.set_value(parent.device_id)
        device_id_label = Gtk.Label(label="Device ID")
        device_id_button.connect("value-changed", button_pressed_callback, "device_id")

        hbox1 = Gtk.HBox()
        hbox1.pack_start(card_id_label, True, False, 0)
        hbox1.pack_start(card_id_button, False, False, 0)
        hbox2 = Gtk.HBox()
        hbox2.pack_start(device_id_label, True, False, 0)
        hbox2.pack_start(device_id_button, False, False, 0)
        vbox = Gtk.VBox()
        vbox.pack_start(hbox1, False, False, 0)
        vbox.pack_start(hbox2, False, False, 0)
        self.get_content_area().add(vbox)
        self.show_all()

class OutputsDialog(Gtk.Dialog):
    """
    Display dialog with list of outputs as individual CheckButtons.
    Button click events are handled by a callback function passed to __init__.
    """

    def __init__(self, parent, button_pressed_callback, *args, **kwargs):
        """
        Args:
            parent: parent window
            button_pressed_callback: callback function handling checkbutton click events. callback accepts 1 arg with the output ID.
        """
        self.log = Defaults.get_logger()
        super().__init__(title="Select Outputs", parent=parent, *args, **kwargs)
        self.set_transient_for(parent)
        self.set_modal(True)
        self.add_button("Close", 0)
        self.set_name("outputs-dialog")
        self.get_content_area().set_size_request(300, 200)
        for o in parent.app.mpd_outputs:
            self.log.debug("output: %s" % o)
            button = Gtk.CheckButton.new_with_label(o['outputname'])
            button.set_active(int(o['outputenabled']))
            self.get_content_area().append(button)
            button.connect("clicked", button_pressed_callback, o['outputid'])
        self.show_all()

class OptionsDialog(Gtk.Dialog):
    """
    Displays dialog of options. Each option is an individual CheckButton.
    Button click events are handled by a callback function passed to __init__.
    """
    def __init__(self, parent, button_pressed_callback, *args, **kwargs):
        """
        Args:
            parent: parent window
            button_pressed_callback: callback function handling checkbutton click events. callback accepts 1 arg with the option name.
        """
        super().__init__(title="Set Options", parent=parent, *args, **kwargs)
        self.set_transient_for(parent)
        self.set_modal(True)
        self.add_button("Close", 0)
        self.set_name("options-dialog")
        self.get_content_area().set_size_request(300, 200)

        self.consume_button = Gtk.CheckButton.new_with_label("Consume")
        self.consume_button.set_active(int(parent.mpd_status['consume']))
        self.consume_button.connect("clicked", button_pressed_callback, "consume")
        self.get_content_area().add(self.consume_button)

        self.shuffle_button = Gtk.CheckButton.new_with_label("Shuffle")
        self.shuffle_button.set_active(int(parent.mpd_status['random']))
        self.shuffle_button.connect("clicked", button_pressed_callback, "random")
        self.get_content_area().add(self.shuffle_button)

        self.repeat_button = Gtk.CheckButton.new_with_label("Repeat")
        self.repeat_button.set_active(int(parent.mpd_status['repeat']))
        self.repeat_button.connect("clicked", button_pressed_callback, "repeat")
        self.get_content_area().add(self.repeat_button)

        self.single_button = Gtk.CheckButton.new_with_label("Single")
        self.single_button.set_active(int(parent.mpd_status['single']))
        self.single_button.connect("clicked", button_pressed_callback, "single")
        self.get_content_area().add(self.single_button)

        self.show_all()

class PlaylistConfirmDialog(Gtk.Dialog):
    """
    """
    def __init__(self, parent, add_item_name, *args, **kwargs):
        super().__init__(title="Update playlist?", parent=parent, *args, **kwargs)
        self.set_transient_for(parent)
        self.set_modal(True)
        self.add_button("Add", 1)
        self.add_button("Replace", 2)
        self.add_button("Cancel", 3)
        self.get_content_area().append(Gtk.Label(label="Selected: " + add_item_name))
        self.get_content_area().set_size_request(300, 100)
        #style_context = self.get_style_context()
        #style_context.add_provider(self.css, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)
        self.connect('response', parent.playlist_dialog_response)
        self.present()

class MetadataLabel(Gtk.Label):
    """
    Gtk.Label with 2 accessible variables: data and type.
    """

    def set_metadata(self, data):
        """
        Set the metadata for the label

        Args:
            data: can be anything
        """
        self.data = data

    def set_metatype(self, t):
        """
        Set the metatype for the label

        Args:
            t: can be anything
        """
        self.type = t

class IndexedListBox(Gtk.ListBox):
    """
    Gtk.ListBox with an index variable. This allows ListBoxes to track their position in list of ListBoxes.
    """
    def set_index(self, index):
        """
        Sets the index of the ListBox

        Args:
            index:  int, the ListBox's position in the parent's list
        """
        self.index = index

class ColumnBrowser(Gtk.Box):
    """
    Column browser for a tree data structure. Inherits from GtkBox.
    Creates columns with a list of GtkScrolledWindows containing a GtkListBox.
    """
    def __init__(self, selected_callback=None, keypress_callback=None, cols=2, spacing=0, hexpand=True, vexpand=True, *args, **kwargs):
        """
        Constructor for the column browser.

        Args:
            selected_callback: callback function for handling row-selected events
            keypress_callback: callback function for handling key-press-event events
            cols: int for number of colums
            hexpand: boolean for whether to set horizontal expansion
            vexpand: boolean for whether to set vertical expansion
        """
        self.log = Defaults.get_logger()
        if not config:
            err_msg = "config cannot be None"
            self.log.error(err_msg)
            raise ValueError(err_msg)
        super().__init__(*args, **kwargs)
        self.set_spacing(spacing)
        if cols < 1:
            raise ValueError("Number of columns must be greater than 1")
        self.columns = []
        for i in range(0, cols):
            scroll = Gtk.ScrolledWindow()
            listbox = IndexedListBox()
            listbox.set_hexpand(hexpand)
            listbox.set_vexpand(vexpand)
            listbox.set_index(i)
            listbox.connect("row-selected", selected_callback)
            #listbox.connect("row-activated", keypress_callback)
            scroll.set_child(listbox)
            self.append(scroll)
            self.columns.append(listbox)

        self.controller = Gtk.EventControllerKey.new()
        self.controller.connect('key-pressed', keypress_callback)
        self.add_controller(self.controller)

    def get_selected_rows(self):
        """
        Gets the child objects of all selected rows.
        Inserting them into a list in order from least to highest column index.

        Returns:
            list of selected rows' child objects.
        """
        self.log.debug("looking for selected row")
        ret = []
        for c in self.columns:
            row = c.get_selected_row()
            if row:
                child = row.get_child()
                ret.append({'type': child.type, 'value': child.get_text(), 'data': child.data})
        return ret

    def set_column_data(self, col_index, data, clear_rest=True):
        """
        Populates a column at col_index.
        Args:
            col_index:  int, column index
            data:  dictionary
            clear_rest: boolean, True: clear all columns to the left as well. default: True
        """
        if clear_rest:
            for i in range(col_index, len(self.columns)):
                self.columns[i].remove_all()

        for i in data:
            #log.debug("data: %s" % i)
            label = MetadataLabel(label=i['value'])
            label.set_metatype(i['type'])
            label.set_metadata(i['data'])
            label.set_halign(Gtk.Align.START)
            self.columns[col_index].append(label)

class MPDFrontWindow(Gtk.ApplicationWindow):
    last_audiofile = ""  ## Tracks albumart for display
    resize_event_on = False  ## Flag for albumart to resize
    browser_full = False  ## Tracks if the browser is fullscreen
    browser_hidden = False  ## Tracks if the browser is hidden
    last_width = 0  ## Tracks width of window when window changes size
    last_height = 0  ## Tracks height of window when window changes size
    playlist_last_selected = None  ## Points to last selected song in playlist
    focus_on = "broswer"  ## Either 'playlist' or 'browser'
    initial_resized = False

    def __init__(self, config=None, application=None, *args, **kwargs):
        self.log = Defaults.get_logger()
        if not config or not app:
            err_msg = "config or app cannot be None"
            self.log.error(err_msg)
            raise ValueError(err_msg)
        super().__init__(application=application, *args, **kwargs)
        self.config = config
        self.set_default_size(int(config.get("main", "width")), int(config.get("main", "height")))
        self.set_resizable(False)
        self.set_decorated(False)
        self.app = application

        self.controller = Gtk.EventControllerKey.new()
        self.controller.connect('key-pressed', self.key_pressed)
        self.add_controller(self.controller)

        ## mainpaned is the toplevel layout container
        self.mainpaned = Gtk.Paned(orientation=Gtk.Orientation.VERTICAL)
        self.mainpaned.set_name("mainpaned")
        #self.mainpaned.set_position(int(config.get("main", "height"))/2)
        self.connect("state_flags_changed", self.on_state_flags_changed)

        self.set_child(self.mainpaned)

        ## Setup browser columns
        self.browser_box = ColumnBrowser(selected_callback=self.broswer_row_selected,
                                         keypress_callback=self.browser_key_pressed, cols=4, spacing=0,
                                         hexpand=True, vexpand=True)
        self.browser_box.set_name("browser")
        self.mainpaned.set_start_child(self.browser_box)
        self.browser_box.set_column_data(0, Constants.browser_1st_column_rows)

        ## Setup bottom half
        self.bottompaned = Gtk.Paned(orientation=Gtk.Orientation.HORIZONTAL)
        #self.bottompaned.set_position(int(config.get("main", "width"))/2)
        self.mainpaned.set_end_child(self.bottompaned)
        self.init_playback_display()

        ## Setup playlist
        self.playlist_list = Gtk.ListBox()
        self.playlist_list.set_name("playlistbox")
        self.playlist_scroll = Gtk.ScrolledWindow()
        self.playlist_scroll.set_name("playlistscroll")
        self.playlist_scroll.set_hexpand(True)
        self.playlist_scroll.set_child(self.playlist_list)
        self.bottompaned.set_end_child(self.playlist_scroll)

        ## Set event handlers
        self.connect("destroy", self.close)
        #self.connect("check-resize", self.window_resized)
        self.previous_button.connect("clicked", self.previous_clicked)
        self.rewind_button.connect("clicked", self.rewind_clicked)
        self.stop_button.connect("clicked", self.stop_clicked)
        self.play_button.connect("clicked", self.play_clicked)
        self.cue_button.connect("clicked", self.cue_clicked)
        self.next_button.connect("clicked", self.next_clicked)
        #self.playlist_list.connect("key-pressed", self.playlist_key_pressed)

        self.update_playback()
        self.update_playlist()


        if re.match(r'yes$', self.config.get("main", "fullscreen"), re.IGNORECASE):
            self.fullscreen()

        self.app.get_albumartists()
        self.app.get_artists()
        self.app.get_albums()
        self.app.get_genres()
        self.app.get_files_list()

        self.playlist_last_selected = 0
        self.playlist_list.select_row(self.playlist_list.get_row_at_index(self.playlist_last_selected))
        self.browser_box.columns[0].select_row(self.browser_box.columns[0].get_row_at_index(0))

    def init_playback_display(self):
        """
        Setup playback grid
        """
        self.playback_grid = Gtk.Grid()
        self.playback_grid.set_name("playback-pane")
        self.bottompaned.set_start_child(self.playback_grid)

        self.playback_info_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        self.playback_grid.attach(self.playback_info_box, 0, 0, 1, 1)

        self.current_title_label = Gtk.Label(label=" ")
        self.current_title_label.set_name("current-title")
        self.current_title_label.set_ellipsize(Pango.EllipsizeMode.END)
        self.current_title_label.set_halign(Gtk.Align.START)
        self.current_title_label.set_valign(Gtk.Align.START)
        #self.current_title_label.set_line_wrap(True)
        self.current_title_label.set_hexpand(True)

        self.current_artist_label = Gtk.Label(label=" ")
        self.current_artist_label.set_name("current-artist")
        self.current_artist_label.set_halign(Gtk.Align.START)
        self.current_artist_label.set_valign(Gtk.Align.START)
        self.current_artist_label.set_ellipsize(Pango.EllipsizeMode.END)
        #self.current_artist_label.set_line_wrap(True)

        self.current_album_label = Gtk.Label(label=" ")
        self.current_album_label.set_name("current-album")
        self.current_album_label.set_halign(Gtk.Align.START)
        self.current_album_label.set_valign(Gtk.Align.START)
        self.current_album_label.set_ellipsize(Pango.EllipsizeMode.END)
        #self.current_album_label.set_line_wrap(True)

        self.stats1_label = Gtk.Label(label=" ")
        self.stats1_label.set_name("stats1")
        self.stats1_label.set_halign(Gtk.Align.START)
        self.stats1_label.set_valign(Gtk.Align.END)

        self.stats2_label = Gtk.Label(label=" ")
        self.stats2_label.set_name("stats2")
        self.stats2_label.set_halign(Gtk.Align.START)
        self.stats2_label.set_valign(Gtk.Align.END)

        self.current_time_label = Gtk.Label(label=" ")
        self.current_time_label.set_name("current-time")
        self.current_time_label.set_halign(Gtk.Align.START)
        self.current_time_label.set_valign(Gtk.Align.END)

        ## Add labels to playback grid
        self.playback_info_box.append(self.current_title_label)
        self.playback_info_box.append(self.current_artist_label)
        self.playback_info_box.append(self.current_album_label)
        self.playback_info_box.append(self.current_time_label)
        self.playback_info_box.append(self.stats2_label)
        self.playback_info_box.append(self.stats1_label)

        ## Setup playback button box
        self.playback_button_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        self.playback_grid.attach(self.playback_button_box, 0, 3, 2, 1)
        self.previous_button = Gtk.Button(label=Constants.symbol_previous)
        self.rewind_button = Gtk.Button(label=Constants.symbol_rewind)
        self.stop_button = Gtk.Button(label=Constants.symbol_stop)
        self.play_button = Gtk.Button(label=Constants.symbol_play)
        self.cue_button = Gtk.Button(label=Constants.symbol_cue)
        self.next_button = Gtk.Button(label=Constants.symbol_next)
        self.playback_button_box.append(self.previous_button)
        self.playback_button_box.append(self.rewind_button)
        self.playback_button_box.append(self.stop_button)
        self.playback_button_box.append(self.play_button)
        self.playback_button_box.append(self.cue_button)
        self.playback_button_box.append(self.next_button)
        self.playback_button_box.set_hexpand(True)

        ## Song progress bar
        self.song_progress = Gtk.LevelBar()
        self.song_progress.set_size_request(-1, 20)
        self.song_progress.set_name("progressbar")
        self.playback_grid.attach(self.song_progress, 0, 2, 2, 1)

        ## Current album art
        self.current_albumart = Gtk.Picture()
        self.current_albumart.set_valign(Gtk.Align.START)
        self.current_albumart.set_vexpand(True)
        #self.current_albumart.set_hexpand(True)
        self.playback_grid.attach(self.current_albumart, 1, 0, 1, 1)

    ##  BEGIN EVENT HANDLERS

    def window_resized(self, widget):
        """
        Handler for window resize event
        """
        #log.debug("Window resize event")
        w = self.get_allocated_width()
        h = self.get_allocated_height()
        if self.last_width != w or self.last_height != h:
            self.last_width = w
            self.last_height = h
            self.resize_event_on = True
            self.resize_widgets()
            self.set_current_albumart()
            self.resize_event_on = False

    def on_keypress(self, controller, keyval, keycode, state):
        #self.log.debug("keypressed: %s %s %s" % (keyval, keycode, state))
        ctrl_pressed = state & Gdk.ModifierType.CONTROL_MASK
        cmd_pressed = state & Gdk.ModifierType.META_MASK
        if keyval in (ord('q'), ord('Q')) and (ctrl_pressed or cmd_pressed):
            self.log.debug("QUIT pressed")
            self.close()

    ##  Keyboard event handlers
    def key_pressed(self, controller, keyval, keycode, state):
        """
        Keypress handler for toplevel widget. Responds to global keys for playback control.
        """
        ctrl_pressed = state & Gdk.ModifierType.CONTROL_MASK
        cmd_pressed = state & Gdk.ModifierType.META_MASK   ## Cmd
        #shift_pressed = state & Gdk.ModifierType.SHIFT_MASK
        #alt_pressed = state & Gdk.ModifierType.ALT_MASK

        error = False
        reconnect = False
        try:
            self.log.debug("Key pressed: %x" % keyval)
            if (ctrl_pressed or cmd_pressed) and keyval in (ord('q'), ord('Q')):
                self.log.debug("QUIT pressed")
                self.close()
            elif keyval == Constants.keyval_play or keyval == ord(self.config.get("keys", "playpause")):
                self.log.debug("PLAY/PAUSE")
                self.app.play_or_pause()
            elif keyval == ord(self.config.get("keys", "stop")):
                self.log.debug("STOP")
                self.app.mpd.stop()
            elif keyval == Constants.keyval_previous or keyval == ord(self.config.get("keys", "previous")):
                self.log.debug("PREVIOUS")
                self.app.mpd.previous()
            elif keyval == Constants.keyval_next or keyval == ord(self.config.get("keys", "next")):
                self.log.debug("NEXT")
                self.app.mpd.next()
            elif keyval == Constants.keyval_rewind or keyval == ord(self.config.get("keys", "rewind")):
                self.log.debug("REWIND")
                self.app.mpd.seekcur("-5")
            elif keyval == Constants.keyval_cue or keyval == ord(self.config.get("keys", "cue")):
                self.log.debug("CUE")
                self.app.mpd.seekcur("+5")

            elif keyval == ord(self.config.get("keys", "outputs")):
                self.outputs_dialog = OutputsDialog(self, self.outputs_changed)
                #response = self.outputs_dialog.run()
                #self.outputs_dialog.destroy()

            elif keyval == ord(self.config.get("keys", "options")):
                self.options_dialog = OptionsDialog(self, self.options_changed)
                #response = self.options_dialog.run()
                #self.options_dialog.destroy()

            elif keyval == ord(self.config.get("keys", "cardselect")):
                self.cards_dialog = CardSelectDialog(self, self.soundcard_changed)
                #response = self.cards_dialog.run()
                #self.cards_dialog.destroy()

            elif keyval == ord(self.config.get("keys", "browser")):
                ## Focus on the last selected row in the browser
                self.focus_on = "broswer"
                selected_items = self.browser_box.get_selected_rows()
                if not len(selected_items):
                    self.browser_box.columns[0].select_row(self.browser_box.columns[0].get_row_at_index(0))
                    selected_items = self.browser_box.get_selected_rows()
                focus_col = self.browser_box.columns[len(selected_items) - 1]
                focus_row = focus_col.get_selected_row()
                focus_row.grab_focus()

            elif keyval == ord(self.config.get("keys", "playlist")):
                ## Focus on the selected row in the playlist
                self.focus_on = "playlist"
                selected_row = self.playlist_list.get_selected_row()
                if not selected_row:
                    selected_row = self.playlist_list.get_row_at_index(0)
                    self.playlist_list.select_row(selected_row)
                selected_row.grab_focus()

            elif keyval == ord(self.config.get("keys", "full_browser")):
                ## Hide bottom pane/fullscreen browser
                if self.mainpaned.get_position() == self.last_height - 1:
                    self.mainpaned.set_position(int(self.last_height / 2))
                    self.resize_event_on = True
                    self.set_current_albumart()
                    self.resize_event_on = False
                else:
                    self.mainpaned.set_position(self.last_height)

            elif keyval == ord(self.config.get("keys", "full_bottom")):
                ## Hide top pane
                if self.mainpaned.get_position() == 0:
                    self.mainpaned.set_position(int(self.last_height / 2))
                else:
                    self.mainpaned.set_position(0)
                self.resize_event_on = True
                self.set_current_albumart()
                self.resize_event_on = False

            elif keyval == ord(self.config.get("keys", "full_playback")):
                ## Hide playlist
                if self.bottompaned.get_position() == self.last_width - 1:
                    self.bottompaned.set_position(int(self.last_width / 2))
                else:
                    self.bottompaned.set_position(self.last_width)
                self.resize_event_on = True
                self.set_current_albumart()
                self.resize_event_on = False

            elif keyval == ord(self.config.get("keys", "full_playlist")):
                ## Hide top pane
                if self.bottompaned.get_position() == 0:
                    self.bottompaned.set_position(int(self.last_width / 2))
                    self.resize_event_on = True
                    self.set_current_albumart()
                    self.resize_event_on = False
                else:
                    self.bottompaned.set_position(0)

            elif keyval == ord('v'):
                self.set_dividers()

            #elif keyval == Gdk.KEY_Right:
            #    self.log.debug("RIGHT")
            #elif keyval == Gdk.KEY_Left:
            ##    self.log.debug("LEFT")
            #elif keyval == Gdk.KEY_Up:
            #    self.log.debug("UP")
            #elif keyval == Gdk.KEY_Down:
            #    self.log.debug("DOWN")
            #else:
            #    self.log.debug("key press: %s" % keyval)

        except (musicpd.ConnectionError, BrokenPipeError) as e:
            self.log.info("previous mpd command failed: %s" % e)
            error = True
            reconnect = True
        except Exception as e:
            self.log.error("Unknown exception: %s" % e)
            error = True
        if reconnect:
            self.mpd_connect()

    def browser_key_pressed(self, controller, keyval, keycode, state):
        """
        Event handler for browser box key presses
        """
        if keyval == Gdk.KEY_Return:
            #log.debug("browser key: ENTER")
            self.add_to_playlist()

        elif keyval == ord(self.config.get("keys", "info")):
            self.browser_info_popup()

    def playlist_key_pressed(self, controller, keyval, keycode, state):
        """
        Event handler for playlist box key presses
        """
        if keyval == Gdk.KEY_Return:
            #log.debug("playlist key: ENTER")
            self.edit_playlist()

        elif keyval == ord(self.config.get("keys", "info")):
            self.playlist_info_popup()
        elif keyval == ord(self.config.get("keys", "moveup")):
            self.playlist_moveup()
        elif keyval == ord(self.config.get("keys", "movedown")):
            self.playlist_movedown()
        elif keyval == ord(self.config.get("keys", "delete")):
            self.playlist_delete()

    ##  Click handlers

    def previous_clicked(self, button):
        """
        Click handler for previous button
        """
        error = False
        try:
            self.mpd.previous()
        except (musicpd.ConnectionError, BrokenPipeError) as e:
            self.log.info("previous failed: %s" % e)
            error = True
        if error:
            self.mpd_connect()
            self.mpd.previous()

    def rewind_clicked(self, button):
        """
        Click handler for rewind button
        """
        error = False
        try:
            self.mpd.seekcur("-5")
        except (musicpd.ConnectionError, BrokenPipeError) as e:
            self.log.info("rewind failed: %s" % e)
            error = True
        if error:
            self.mpd_connect()
            self.mpd.seekcur("-5")

    def stop_clicked(self, button):
        """
        Click handler for stop button
        """
        error = False
        try:
            self.mpd.stop()
        except (musicpd.ConnectionError, BrokenPipeError) as e:
            self.log.info("stop failed: %s" % e)
            error = True
        if error:
            self.mpd_connect()
            self.mpd.stop()

    def play_clicked(self, button):
        """
        Click handler for play/pause button
        """
        self.app.play_or_pause()

    def cue_clicked(self, button):
        """
        Click handler for cue button
        """
        error = False
        try:
            self.mpd.seekcur("+5")
        except (musicpd.ConnectionError, BrokenPipeError) as e:
            self.log.info("cue failed: %s" % e)
            error = True
        if error:
            self.mpd_connect()
            self.mpd.seekcur("+5")

    def next_clicked(self, button):
        """
        Click handler for next button
        """
        error = False
        try:
            self.mpd.next()
        except (musicpd.ConnectionError, BrokenPipeError) as e:
            self.log.info("next failed: %s" % e)
            error = True
        if error:
            self.mpd_connect()
            self.mpd.next()

    ##  Selected handlers

    def broswer_row_selected(self, listbox, row):
        """
        Handler for selection event in browser_box
        """
        if not row:
            return

        child = row.get_child()
        if child:
            metatype = child.type
            value = child.get_text()
            self.log.debug("col %d, %s: %s" % (listbox.index, metatype, value))
            if metatype == "category":
                if value == "Album Artists":
                    artists = self.app.get_albumartists()
                    #self.log.debug("albumartists: %s" % artists)
                    rows = []
                    for a in artists:
                        rows.append({'type': 'albumartist', 'value': a, 'data': None})
                    self.browser_box.set_column_data(listbox.index + 1, rows)
                    self.browser_box.columns[listbox.index + 1].set_sort_func(listbox_cmp_filtered, None, False)

                elif value == "Artists":
                    artists = self.app.get_artists()
                    #log.debug("artists: %s" % artists)
                    rows = []
                    for a in artists:
                        rows.append({'type': 'artist', 'value': a, 'data': None})
                    self.browser_box.set_column_data(listbox.index + 1, rows)
                    self.browser_box.columns[listbox.index + 1].set_sort_func(listbox_cmp_filtered, None, False)

                elif value == "Albums":
                    albums = self.app.get_albums()
                    rows = []
                    for a in albums:
                        rows.append({'type': 'album', 'value': a, 'data': None})
                    self.browser_box.set_column_data(listbox.index + 1, rows)
                    self.browser_box.columns[listbox.index + 1].set_sort_func(listbox_cmp_filtered, None, False)

                elif value == "Genres":
                    genres = self.app.get_genres()
                    rows = []
                    for g in genres:
                        rows.append({'type': 'genre', 'value': g, 'data': None})
                    self.browser_box.set_column_data(listbox.index + 1, rows)
                    self.browser_box.columns[listbox.index + 1].set_sort_func(listbox_cmp, None, False)

                elif value == "Files":
                    files = self.app.get_files_list()
                    #log.debug("files: %s" % files)
                    rows = []
                    for f in files:
                        subf = self.app.get_files_list(f['data']['dir'])
                        for f2 in subf:
                            rows.append(
                                {'type': f2['type'], 'value': f['value'] + "/" + f2['value'], 'data': f2['data'], })
                    self.browser_box.set_column_data(listbox.index + 1, rows)
                    self.browser_box.columns[listbox.index + 1].set_sort_func(listbox_cmp, None, False)

                else:
                    self.browser_box.set_column_data(listbox.index + 1, [])

            elif metatype == "albumartist":
                albums = self.app.get_albums_by_albumartist(value)
                #log.debug("albums: %s" % albums)
                rows = []
                for a in albums:
                    rows.append({'type': 'album', 'value': a, 'data': None})
                self.browser_box.set_column_data(listbox.index + 1, rows)
                self.browser_box.columns[listbox.index + 1].set_sort_func(listbox_cmp, None, False)

            elif metatype == "artist":
                albums = self.app.get_albums_by_artist(value)
                #log.debug("albums: %s" % albums)
                rows = []
                for a in albums:
                    rows.append({'type': 'album', 'value': a, 'data': None})
                self.browser_box.set_column_data(listbox.index + 1, rows)
                self.browser_box.columns[listbox.index + 1].set_sort_func(listbox_cmp, None, False)

            elif metatype == "genre":
                albums = self.app.get_albums_by_genre(value)
                #log.debug("albums: %s" % albums)
                rows = []
                for a in albums:
                    rows.append({'type': 'album', 'value': a, 'data': None})
                self.browser_box.set_column_data(listbox.index + 1, rows)
                self.browser_box.columns[listbox.index + 1].set_sort_func(listbox_cmp, None, False)

            elif metatype == "album":
                selected_items = self.browser_box.get_selected_rows()
                #self.log.debug("selected items: %s" % selected_items)
                last_type = selected_items[listbox.index - 1]['type']
                last_value = selected_items[listbox.index - 1]['value']
                #self.log.debug("%s %s" % (value, last_value))
                songs = None
                if last_type == "albumartist":
                    songs = self.app.get_songs_by_album_by_albumartist(value, last_value)

                elif last_type == "artist":
                    songs = self.app.get_songs_by_album_by_artist(value, last_value)

                elif last_type == "category":
                    songs = self.app.get_songs_by_album(value)

                elif last_type == "genre":
                    songs = self.app.get_songs_by_album_by_genre(value, last_value)

                rows = []
                if songs:
                    for s in songs:
                        #log.debug(s)
                        track = ""
                        if 'track' in s:
                            track = re.sub(r'/.*', '', s['track'])
                        if 'title' in s:
                            rows.append({'type': 'song', 'value': track + " " + s['title'], 'data': s})
                        else:
                            rows.append({'type': 'song', 'value': os.path.basename(s['file']), 'data': s})
                self.browser_box.set_column_data(listbox.index + 1, rows)
                self.browser_box.columns[listbox.index + 1].set_sort_func(listbox_cmp_by_track, None, False)

            elif metatype == "directory":
                files = self.app.get_files_list(child.data['dir'])
                rows = []
                for f in files:
                    #log.debug("directory: %s" % f)
                    rows.append(f)
                self.browser_box.set_column_data(listbox.index + 1, rows)
                self.browser_box.columns[listbox.index + 1].set_sort_func(listbox_cmp, None, False)

    ##  END EVENT HANDLERS

    def get_albumart(self, audiofile):
        """
        Extract album art from a file, or look for a cover in its directory.
        Tries to fetch art from Last.fm if all else fails.

        Args:
            audiofile: string, path of the file containing the audio data

        Returns:
            raw image data
        """
        img_data = None

        ## Try to find album art in the media file
        try:
            if re.search(r'\.flac$', self.mpd_currentsong['file'], re.IGNORECASE):
                a = FLAC(audiofile)
                if len(a.pictures):
                    img_data = a.pictures[0].data
            elif re.search(r'\.m4a$', self.mpd_currentsong['file'], re.IGNORECASE):
                a = MP4(audiofile)
                if 'covr' in a.tags:
                    if len(a.tags['covr']):
                        img_data = a.tags['covr'][0]
            else:
                a = mutagen.File(audiofile)
                for k in a.keys():
                    if re.match(r'APIC:', k):
                        img_data = a[k].data
                        break
        except Exception as e:
            self.log.error("could not open audio file: %s" % e)

        ## Look for album art on the directory of the media file
        if not img_data:
            cover_path = ""
            song_dir = self.config.get("main", "music_dir") + "/" + os.path.dirname(self.mpd_currentsong['file'])
            try:
                for f in os.listdir(song_dir):
                    if re.match(r'cover\.(jpg|png|jpeg)', f, re.IGNORECASE):
                        cover_path = song_dir + "/" + f
                        break
                self.log.debug("looking for cover file: %s" % cover_path)
                if os.path.isfile(cover_path):
                    cf = open(cover_path, 'rb')
                    img_data = cf.read()
                    cf.close()
            except Exception as e:
                self.log.error("error reading cover file: %s" % e)
        return img_data

    def set_current_albumart(self):
        """
        Load and display image of current song if it has changed since the last time this function was run, or on the first run.
        Loads image data into a PIL.Image object, then into a GdkPixbuf object, then into a Gtk.Image object for display.
        """
        if not self.mpd_currentsong or not 'file' in self.mpd_currentsong.keys():
            return

        audiofile = self.config.get("main", "music_dir") + "/" + self.mpd_currentsong['file']
        if self.last_audiofile != audiofile:
            ## The file has changed since the last update, get the new album art.
            self.log.debug("new cover file, updating")
            img_data = self.get_albumart(audiofile)
            if img_data:
                ## Album art retrieved, load it into a pixbuf
                img = Image.open(io.BytesIO(img_data))
                img_bytes = GLib.Bytes.new(img.tobytes())
                self.log.debug("image size: %d x %d" % img.size)
                w, h = img.size
                if img.has_transparency_data:
                    self.current_albumart_pixbuf = GdkPixbuf.Pixbuf.new_from_bytes(img_bytes, GdkPixbuf.Colorspace.RGB,
                                                                                   True, 8, w, h, w * 4)
                else:
                    self.current_albumart_pixbuf = GdkPixbuf.Pixbuf.new_from_bytes(img_bytes, GdkPixbuf.Colorspace.RGB,
                                                                                   False, 8, w, h, w * 3)
            else:
                ## No album art, clear the image in the UI.
                self.current_albumart.clear()
                self.last_audiofile = audiofile
                return

        if self.last_audiofile != audiofile or self.resize_event_on:
            ## Update the image
            if self.current_albumart_pixbuf:
                self.current_albumart.set_pixbuf(self.current_albumart_pixbuf)
            else:
                self.log.debug("could not get pixbuf, clearing album art")
                self.current_albumart.clear()
        self.last_audiofile = audiofile

    def update_playback(self):
        """
        Updates playback display.
        Fetches the current status and song from MPD. Sets the text on each label.
        """

        ## Fetch current status and song from MPD.
        error = False
        try:
            self.mpd_status = self.app.mpd_status = self.app.mpd.status()
            self.mpd_currentsong = self.app.mpd.currentsong()
            self.log.debug("status: %s" % self.mpd_status)
            self.log.debug("currentsong: %s" % self.mpd_currentsong)
        except (musicpd.ConnectionError, BrokenPipeError) as e:
            self.log.info("Attempting reconnect: %s" % e)
            error = True
        if error:
            self.app.mpd_connect()
            return

        ## Set labels with song information. Set to empty if there is no current song.
        if self.mpd_currentsong:
            if 'artist' in self.mpd_currentsong and 'title' in self.mpd_currentsong and 'album' in self.mpd_currentsong:
                self.current_title_label.set_text(self.mpd_currentsong['title'])
                self.current_artist_label.set_text(self.mpd_currentsong['artist'])
                self.current_artist_label.set_ellipsize(Pango.EllipsizeMode.END)
                self.current_artist_label.set_wrap(False)
                self.current_album_label.set_text(self.mpd_currentsong['album'])
            else:
                filename = os.path.basename(self.mpd_currentsong['file'])
                self.current_title_label.set_text(" ")
                self.current_artist_label.set_text(filename)
                self.current_artist_label.set_ellipsize(Pango.EllipsizeMode.NONE)
                self.current_artist_label.set_wrap(True)
                self.current_artist_label.set_wrap_mode(Pango.WrapMode.WORD_CHAR)
                self.current_album_label.set_text(" ")
        else:
            self.current_title_label.set_text(" ")
            self.current_artist_label.set_text(" ")
            self.current_album_label.set_text(" ")

        ## Get stream rates, format
        freq = bits = bitrate = chs = ""
        if 'audio' in self.mpd_status.keys():
            if re.match(r'dsd\d+:', self.mpd_status['audio']):
                bits = "dsd"
                freq, chs = re.split(r':', self.mpd_status['audio'], maxsplit=1)
            else:
                freq, bits, chs = re.split(r':', self.mpd_status['audio'], maxsplit=2)
        if 'bitrate' in self.mpd_status.keys():
            bitrate = self.mpd_status['bitrate']

        ## Format and set stream/dac information. Set to empty if there is no info to display
        format_text = dac_text = ""
        if freq and bits and chs and bitrate:
            if bits == "dsd":
                if re.match(r'dsd', freq):
                    format_text = freq
                else:
                    format_text = "%2.1f MHz DSD" % (float(bitrate) / 1000)
            elif bits == "f":
                format_text = "%3.1f kHz float PCM" % (float(freq) / 1000)
            else:
                format_text = "%3.1f kHz %s bit PCM" % (float(freq) / 1000, bits)

            ## Get and format DAC rate, format
            dac_freq = dac_bits = ""
            proc_file = Constants.proc_file_fmt % (self.config.get("main", "sound_card"), self.config.get("main", "sound_device"), "0")
            #log.debug("proc file: %s" % proc_file)
            if os.path.exists(proc_file):
                lines = ()
                try:
                    fh = open(proc_file)
                    lines = fh.readlines()
                    fh.close()
                except Exception as e:
                    self.log.error("opening up proc file: %s" % e)
                for line in lines:
                    line = line.rstrip()
                    #log.debug("procfile line: %s" % line)
                    if re.match(r'rate:', line):
                        (junk1, dac_freq, junk2) = re.split(r' ', line, maxsplit=2)
                    elif re.match(r'format:', line):
                        (junk1, dac_bits) = re.split(r': ', line, maxsplit=1)
                    elif re.match(r'closed', line):
                        break
                if dac_freq and dac_bits:
                    num_bits = 0
                    if dac_bits in ("S32_LE"):
                        num_bits = 32
                    elif dac_bits in ("S24_LE", "S24_3LE"):
                        num_bits = 24
                    elif dac_bits in ("S16_LE"):
                        num_bits = 16
                    dac_text = "%3.1f kHz %d bit" % (float(dac_freq) / 1000, num_bits)
            else:
                #log.debug("proc file does not exist")
                None

            self.stats1_label.set_markup("<small><b>src:</b></small> " + format_text + " @ " + bitrate + " kbps")
            self.stats2_label.set_markup("<small><b>dac:</b></small> " + dac_text)
        else:
            self.stats1_label.set_text(" ")
            self.stats2_label.set_text(" ")

        ## Format and set time information and state
        if 'time' in self.mpd_status.keys():
            print_state = "Playing"
            if self.mpd_status['state'] == "pause":
                print_state = "Paused"
            self.song_progress.set_max_value(int(float(self.mpd_status['duration'])))
            self.song_progress.set_value(int(float(self.mpd_status['elapsed'])))
            self.current_time_label.set_text(pp_time(int(float(self.mpd_status['elapsed']))) + " / " + pp_time(
                int(float(self.mpd_status['duration']))) + " " + print_state)
        elif self.mpd_status['state'] == "stop":
            self.song_progress.set_value(0)
            self.current_time_label.set_text("Stopped")
            self.last_update_offset = 0

        self.set_current_albumart()

    def get_playlist(self):
        """
        Query for playlist. Clean up data before returning.

        Returns:
            list of filenames
        """
        error = False
        try:
            plist = self.app.mpd.playlistinfo()
            #self.log.debug("playlist: %s" % plist)
        except (musicpd.ConnectionError, BrokenPipeError) as e:
            self.log.error("could not fetch playlist: %s" % e)
            error = True
        if error:
            self.app.mpd_connect()
            return None
        #return plist
        playlist = []
        for song in plist:
            #self.log.debug("file_info: %s" % song)
            playlist.append(song)
        return playlist

    def update_playlist(self):
        """
        Updates playlist display. Makes MPD call for the playlist.
        Clears the current playlist. Adds song titles to the listbox.
        """
        self.playlist_list.remove_all()
        playlist = self.get_playlist()
        #self.log.debug("playlist: %s" % playlist)
        if not playlist:
            return

        ## Add songs to the list
        for song in playlist:
            self.log.debug("adding song to playlist: %s" % song['title'])
            label_text = ""
            if 'track' in song and 'time' in song and 'title' in song:
                label_text = re.sub(r'/.*', '', html.escape(song['track'])) + " (" + html.escape(
                    pp_time(song['time'])) + ") <b>" + html.escape(song['title']) + "</b>"
            else:
                label_text = os.path.basename(song['file'])
            label = MetadataLabel()
            label.set_markup(label_text)
            label.set_metatype('song')
            label.set_metadata(song)
            label.set_halign(Gtk.Align.START)
            self.playlist_list.append(label)

        if self.playlist_last_selected != None:
            self.playlist_list.select_row(self.playlist_list.get_row_at_index(self.playlist_last_selected))

        if self.focus_on == "playlist" and self.playlist_list.get_row_at_index(self.playlist_last_selected):
            self.playlist_list.get_row_at_index(self.playlist_last_selected).grab_focus()

        if 'pos' in self.mpd_currentsong:
            self.playlist_list.get_row_at_index(int(self.mpd_currentsong['pos'])).set_name("current")
        self.log.debug("playlist refresh complete")

    def add_to_playlist(self):
        """
        Displays confirmation dialog, presenting options to add, replace or cancel.
        """
        self.browser_selected_items = self.browser_box.get_selected_rows()
        #log.debug("selected items: %s" % selected_items)
        if not self.browser_selected_items[-1]['type'] in ("album", "song", "file"):
            return
        add_item_name = ""
        for i in range(1, len(self.browser_selected_items)):
            if self.browser_selected_items[i]['type'] == "song":
                add_item_name += self.browser_selected_items[i]['data']['title'] + " "
            else:
                add_item_name += self.browser_selected_items[i]['value'] + " "

        self.playlist_confirm_dialog = PlaylistConfirmDialog(self, add_item_name)

    def edit_playlist(self):
        """
        Displays dialog with playlist edit options. Performs task based on user input.
        Play, move song up in playlist, down in playlist, delete from playlist.
        """
        #index = self.playlist_list.get_selected_row().get_index()
        song = self.playlist_list.get_selected_row().get_child().data
        #log.debug("selected song: %s" % song)

        self.edit_playlist_dialog = Gtk.Dialog("Edit playlist", self)
        self.edit_playlist_dialog.set_modal(True)
        for button_tuple in (("Play", 4), ("Up", 1), ("Down", 2), ("Delete", 3), ("Cancel", -4)):
            self.edit_playlist_dialog.add_button(button_tuple[0], button_tuple[1])
        if 'title' in song:
            self.edit_playlist_dialog.get_content_area().add(Gtk.Label(label="Edit: " + song['title']))
        else:
            self.edit_playlist_dialog.get_content_area().add(Gtk.Label(label="Edit: " + song['file']))
        self.edit_playlist_dialog.get_content_area().set_size_request(300, 100)
        style_context = self.edit_playlist_dialog.get_style_context()
        style_context.add_provider(self.css, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)
        self.edit_playlist_dialog.show_all();
        response = self.edit_playlist_dialog.run()
        self.edit_playlist_dialog.destroy()
        #log.debug("dialog response: %s" % response)

        if response == 1:
            self.playlist_moveup()
        elif response == 2:
            self.playlist_movedown()
        elif response == 3:
            self.playlist_delete()
        elif response == 4:
            self.app.mpd.playid(song['id'])

    def playlist_info_popup(self):
        """
        Call SongInfoDialog to display the song data from the selected playlist row
        """
        song = self.playlist_list.get_selected_row().get_child().data
        if song is None:
            return
        self.log.debug("song info: %s" % song)
        dialog = SongInfoDialog(self, song)
        #dialog.run()
        #dialog.destroy()

    def browser_info_popup(self):
        """
        Call SongInfoDialog to display the song data from the selected browser row
        """
        song = self.browser_box.get_selected_rows()[-1]['data']
        if song is None:
            return
        self.log.debug("song info: %s" % song)
        dialog = SongInfoDialog(self, song)
        #dialog.run()
        #dialog.destroy()

    def outputs_changed(self, button, outputid):
        """
        Callback function passed to OutputsDialog.
        Expects the output ID, enables or disables the output based on the button's state.

        Args:
            button: Gtk.Button, event source
            outputid: output ID from the button

        """
        #log.debug("outputid: %s, %s" % (outputid, button.get_active()))
        error = False
        try:
            if button.get_active():
                self.app.mpd.enableoutput(outputid)
            else:
                self.app.mpd.disableoutput(outputid)
            self.app.mpd_outputs = self.app.mpd.outputs()
        except (musicpd.ConnectionError, BrokenPipeError) as e:
            self.log.info("previous mpd command failed: %s" % e)
            error = True
        if error:
            self.app.mpd_connect()

    def options_changed(self, button, option):
        """
        Callback function passed to OptionsDialog.
        Sets/unsets options based on input.

        Args:
            button: Gtk.Button, event source
            option: name of the option to change
        """
        error = False
        try:
            if option == "consume":
                self.app.mpd.consume(int(button.get_active()))
            elif option == "random":
                self.app.mpd.random(int(button.get_active()))
            elif option == "repeat":
                self.app.mpd.repeat(int(button.get_active()))
            elif option == "single":
                self.app.mpd.single(int(button.get_active()))
            else:
                self.log.info("unhandled option: %s" % option)
        except (musicpd.ConnectionError, BrokenPipeError) as e:
            self.log.info("previous mpd command failed: %s" % e)
            error = True
        if error:
            self.app.mpd_connect()

    def soundcard_changed(self, button, change):
        """
        """
        self.log.debug("changing sound card: %s = %s" % (change, button.get_value_as_int()))
        if change == "card_id":
            self.card_id = button.get_value_as_int()
        elif change == "device_id":
            self.device_id = button.get_value_as_int()
        self.update_playback()

    def playlist_moveup(self):
        index = self.playlist_list.get_selected_row().get_index()
        song = self.playlist_list.get_selected_row().get_child().data
        self.log.debug("moving song up 1: '%s'" % song['title'])
        if index > 0:
            try:
                index -= 1
                self.app.mpd.moveid(song['id'], index)
            except (musicpd.ConnectionError, BrokenPipeError) as e:
                self.log.error("could not move song up: %s" % e)
                self.mpd_connect()
                return None
            except Exception as e:
                self.log.error("unknown error could not move song up: %s" % e)
                return None
        self.playlist_last_selected = index
        self.focus_on = "playlist"

    def playlist_movedown(self):
        index = self.playlist_list.get_selected_row().get_index()
        song = self.playlist_list.get_selected_row().get_child().data
        self.log.debug("moving song down 1: '%s'" % song['title'])
        if index + 1 < len(self.playlist_list.get_children()):
            try:
                self.mpd.moveid(song['id'], index + 1)
            except (musicpd.ConnectionError, BrokenPipeError) as e:
                self.log.error("could not move song down: %s" % e)
                self.mpd_connect()
                return None
            except Exception as e:
                self.log.error("unknown error could not move song down: %s" % e)
                return None
        self.playlist_last_selected = index+1
        self.focus_on = "playlist"

    def playlist_delete(self):
        index = self.playlist_list.get_selected_row().get_index()
        song = self.playlist_list.get_selected_row().get_child().data
        self.log.debug("deleting song: '%s'" % song['title'])
        try:
            index -= 1
            if index < 0:
                index = 0
            self.app.mpd.deleteid(song['id'])
        except (musicpd.ConnectionError, BrokenPipeError) as e:
            self.log.error("could not delete song: %s" % e)
            self.app.mpd_connect()
        except Exception as e:
            self.log.error("unknown error could not delete song: %s" % e)
            return None
        self.playlist_last_selected = index
        self.focus_on = "playlist"

    ## New methods
    def playlist_dialog_response(self, dialog, response):
        self.log.debug("dialog response: %s" % response)
        dialog.destroy()

        error = False
        try:
            if response == 2:
                ## Clear list before adding for "replace"
                self.app.mpd.clear()

            if response in (1, 2):
                if self.browser_selected_items[-1]['type'] in ("song", "file"):
                    #log.debug("adding song: %s" % selected_items[-1]['data']['title'])
                    self.app.mpd.add(self.browser_selected_items[-1]['data']['file'])
                elif self.browser_selected_items[-1]['type'] == "album":
                    #log.debug("adding album: %s" % selected_items[-1]['value'])
                    if self.browser_selected_items[-2]['type'] == "artist":
                        self.app.mpd.findadd("artist", self.browser_selected_items[-2]['value'], "album", self.browser_selected_items[-1]['value'])
                    elif self.browser_selected_items[-2]['type'] == "albumartist":
                        self.app.mpd.findadd("albumartist", self.browser_selected_items[-2]['value'], "album",
                                         self.browser_selected_items[-1]['value'])
                    elif self.browser_selected_items[-2]['type'] == "genre":
                        self.app.mpd.findadd("genre", self.browser_selected_items[-2]['value'], "album", self.browser_selected_items[-1]['value'])


        except (musicpd.ConnectionError, BrokenPipeError) as e:
            self.log.error("adding to playlist: %s" % e)
            error = True
        if error:
            self.mpd_connect()

    def on_mainpaned_show(self, widget, user_data):
        self.log.debug("showed mainpaned, height: %d, %s" % (self.get_height(), user_data))
        if self.get_height():
            self.mainpaned.set_position(self.get_height()/2)
        else:
            self.mainpaned.set_position(self.props.default_height / 2)

    def on_state_flags_changed(self, widget=None, flags=None):
        #self.log.debug("state flags: %s" % flags)
        if not self.initial_resized and (flags & Gtk.StateFlags.FOCUS_WITHIN):
            self.set_dividers()
            self.initial_resized = True

    def set_dividers(self):
        self.log.debug("setting dividers")
        if self.get_height():
            self.mainpaned.set_position(self.get_height()/2)
        else:
            self.mainpaned.set_position(self.props.default_height/2)
        if self.get_width():
            self.bottompaned.set_position(self.get_width()/2)
        else:
            self.bottompaned.set_position(self.props.default_width/2)
        #self.set_current_albumart()

class MPDFrontApp(Gtk.Application):
    css_provider = None
    mpd_client = None
    mpd_idle_client = None
    last_update_time = 0  ## Epoch time of last display update
    last_update_offset = 0  ## Time offset into a song at the last display update

    def __init__(self, config=None, css_file=None, *args, **kwargs):
        self.log = Defaults.get_logger()
        if not config:
            err_msg = "config cannot be None"
            self.log.error(err_msg)
            raise ValueError(err_msg)
        super().__init__(*args, **kwargs)
        self.config = config
        self.css_file = css_file
        self.connect('activate', self.on_activate)
        self.connect('shutdown', self.on_quit)

        try:
            self.mpd_connect()
            self.mpd_idle = MPDIdleClient(config.get("main", "host"), int(config.get("main", "port")), app=self)
        except Exception as e:
            self.log.error("could not connect to mpd: %s" % e)
            raise e
        self.mpd_stats = self.mpd.stats()
        self.log.debug("mpd stats: %s" % self.mpd_stats)
        self.mpd_outputs = self.mpd.outputs()
        self.log.debug("mpd outputs: %s" % self.mpd_outputs)

        self.refresh_playback_timeout_id = GLib.timeout_add(500, self.refresh_playback)

    def on_activate(self, app):
        self.window = MPDFrontWindow(application=self, config=self.config)
        if self.css_file and os.path.isfile(self.css_file):
            self.log.debug("reading css file: %s" % self.css_file)
            self.css_provider = Gtk.CssProvider.new()
            try:
                self.css_provider.load_from_path(self.css_file)
                display = Gtk.Widget.get_display(self.window)
                Gtk.StyleContext.add_provider_for_display(display, self.css_provider, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)
            except Exception as e:
                self.log.error("could not load CSS: %s" % e)
                raise e
        self.window.present()
        self.window.set_dividers()

    def on_quit(self, app):
        self.quit()

    def mpd_connect(self):
        """
        Connect to MPD. Requires mpd_host and mpd_port.

        Returns:
            boolean, True if connected, False if not
        """
        try:
            host = config.get("main", "host")
            port = int(config.get("main", "port"))
            self.mpd = musicpd.MPDClient()
            self.mpd.connect(host, port)
            self.log.debug("connected to MPD %s:%d" % (host, port))
        except Exception as e:
            self.log.fatal("Could not connect to MPD %s:%d: %s" % (host, port, e))
            raise e
        return True

    def play_or_pause(self):
        """
        Check the player status, play if stopped, pause otherwise.
        """
        error = False
        #if self.mpd_status['state'] == "stop":
        if True:
            try:
                self.mpd.play()
            except (musicpd.ConnectionError, BrokenPipeError) as e:
                self.log.info("play failed: %s" % e)
                error = True
            if error:
                self.mpd_connect()
                self.mpd.play()
        else:
            try:
                self.mpd.pause()
            except (musicpd.ConnectionError, BrokenPipeError) as e:
                self.log.info("pause failed: %s" % e)
                error = True
            if error:
                self.mpd_connect()
                self.mpd.pause()

    def get_artists(self, mpd=None):
        """
        Gets the list of artists from mpd, enters artists into db_cache if needed

        Args:
            mpd: Optional musicpd.MPDClient object. If not supplied, the object's mpd object will be used.

        Returns:
            list of artist names
        """
        if not mpd:
            mpd = self.mpd

        if not len(MPDDataCache.cache['Artists']):
            error = False
            try:
                recv = mpd.list("artist")
                #log.debug("artists: %s" % recv)
            except (musicpd.ConnectionError, BrokenPipeError) as e:
                self.log.fatal("get artists failed: %s" % e)
                error = True
            if error:
                self.mpd_connect()
                return None

            for i in recv:
                if i == "":
                    continue
                #log.debug("Adding to cache artist: %s" % i)
                MPDDataCache.cache['Artists'][i] = {}

        return MPDDataCache.cache['Artists'].keys()

    def get_albumartists(self):
        """
        Gets the list of albumartists from mpd, enters albumartists into db_cache if needed

        Args:
            mpd: Optional musicpd.MPDClient object. If not supplied, the object's mpd object will be used.

        Returns:
            list of artist names
        """
        if not len(MPDDataCache.cache['Album Artists']):
            error = False
            try:
                recv = self.mpd.list("albumartist")
                #log.debug("albumartists: %s" % recv)
            except (musicpd.ConnectionError, BrokenPipeError) as e:
                self.log.fatal("get albumartists failed: %s" % e)
                error = True
            if error:
                self.mpd_connect()
                return None

            for i in recv:
                if i == "":
                    continue
                #log.debug("Adding to cache albumartist: %s" % i)
                MPDDataCache.cache['Album Artists'][i] = {}

        return MPDDataCache.cache['Album Artists'].keys()

    def get_albums(self, mpd=None):
        """
        Gets the list of albums from mpd, enters albums into db_cache if needed

        Args:
            mpd: Optional musicpd.MPDClient object. If not supplied, the object's mpd object will be used.

        Returns:
            list of album names
        """
        if not mpd:
            mpd = self.mpd

        if not len(MPDDataCache.cache['Albums']):
            error = False
            try:
                recv = mpd.list("album")
                #log.debug("albums: %s" % recv)
            except (musicpd.ConnectionError, BrokenPipeError) as e:
                self.log.fatal("get albums failed: %s" % e)
                error = True
            if error:
                self.mpd_connect()
                return None

            for i in recv:
                if i == "":
                    continue
                #log.debug("Adding to cache album: %s" % i)
                MPDDataCache.cache['Albums'][i] = {}

        return MPDDataCache.cache['Albums'].keys()

    def get_albums_by_artist(self, artist, mpd=None):
        """
        Gets the list of albums by an artist from mpd, enters albums into db_cache if needed

        Args:
            mpd: Optional musicpd.MPDClient object. If not supplied, the object's mpd object will be used.

        Returns:
            list of album names by an artist
        """
        if not mpd:
            mpd = self.mpd
        if not artist in MPDDataCache.cache['Artists']:
            MPDDataCache.cache['Artists'][artist] = {}

        if not len(MPDDataCache.cache['Artists'][artist]):
            error = False
            try:
                recv = mpd.list("album", artist)
                #log.debug("albums: %s" % recv)
            except (musicpd.ConnectionError, BrokenPipeError) as e:
                self.log.fatal("get albums by artist failed: %s" % e)
                error = True
            if error:
                self.mpd_connect()
                return None

            for i in recv:
                if i == "":
                    continue
                #log.debug("Adding to cache artist / album: %s / %s" % (artist, i))
                MPDDataCache.cache['Artists'][artist][i] = []

        return MPDDataCache.cache['Artists'][artist]

    def get_albums_by_albumartist(self, artist, mpd=None):
        """
        Gets the list of albums by an albumartist from mpd, enters albums into db_cache if needed

        Args:
            mpd: Optional musicpd.MPDClient object. If not supplied, the object's mpd object will be used.

        Returns:
            list of album names by an albumartist
        """
        if not mpd:
            mpd = self.mpd
        if not artist in MPDDataCache.cache['Album Artists']:
            MPDDataCache.cache['Album Artists'][artist] = {}

        if not len(MPDDataCache.cache['Album Artists'][artist]):
            error = False
            try:
                recv = mpd.list("album", "albumartist", artist)
                #log.debug("albums: %s" % recv)
            except (musicpd.ConnectionError, BrokenPipeError) as e:
                self.log.fatal("get albums by albumartist failed: %s" % e)
                error = True
            if error:
                self.mpd_connect()
                return None

            for i in recv:
                if i == "":
                    continue
                #log.debug("Adding to cache artist / album: %s / %s" % (artist, i))
                MPDDataCache.cache['Album Artists'][artist][i] = []

        return MPDDataCache.cache['Album Artists'][artist]

    def get_songs_by_album_by_artist(self, album, artist, mpd=None):
        """
        Finds songs by album and artist.

        Args:
            album: name of the album
            artist: name of the artist
            mpd: Optional musicpd.MPDClient object. If not supplied, the object's mpd object will be used.

        Returns:
            list of dictionaries containing song data
        """
        if not mpd:
            mpd = self.mpd

        if not len(MPDDataCache.cache['Artists'][artist][album]):
            error = False
            try:
                recv = self.mpd.find("artist", artist, "album", album)
                #log.debug("songs: %s" % recv)
            except (musicpd.ConnectionError, BrokenPipeError) as e:
                self.log.fatal("get songs by album by artist failed: %s" % e)
                error = True
            if error:
                self.mpd_connect()
                return None

            for i in recv:
                if i == "":
                    continue
                #log.debug("Adding to cache artist / album / song: %s / %s / %s" % (artist, album, i))
                MPDDataCache.cache['Artists'][artist][album].append(i)

        return MPDDataCache.cache['Artists'][artist][album]

    def get_songs_by_album_by_genre(self, album, genre, mpd=None):
        """
        Finds songs by album and artist.

        Args:
            album: name of the album
            genre: name of the genre
            mpd: Optional musicpd.MPDClient object. If not supplied, the object's mpd object will be used.

        Returns:
            list of dictionaries containing song data
        """
        if not mpd:
            mpd = self.mpd

        if not len(MPDDataCache.cache['Genres'][genre][album]):
            error = False
            try:
                recv = self.mpd.find("genre", genre, "album", album)
                #log.debug("songs: %s" % recv)
            except (musicpd.ConnectionError, BrokenPipeError) as e:
                self.log.fatal("get songs by album by genre failed: %s" % e)
                error = True
            if error:
                self.mpd_connect()
                return None

            for i in recv:
                if i == "":
                    continue
                #log.debug("Adding to cache genre / album / song: %s / %s / %s" % (genre, album, i))
                MPDDataCache.cache['Genres'][genre][album].append(i)

        return MPDDataCache.cache['Genres'][genre][album]

    def get_songs_by_album_by_albumartist(self, album, artist, mpd=None):
        """
        Finds songs by album and albumartist.

        Args:
            album: name of the album
            artist: name of the albumartist
            mpd: Optional musicpd.MPDClient object. If not supplied, the object's mpd object will be used.

        Returns:
            list of dictionaries containing song data
        """
        if not mpd:
            mpd = self.mpd

        if not len(MPDDataCache.cache['Album Artists'][artist][album]):
            error = False
            try:
                recv = self.mpd.find("albumartist", artist, "album", album)
                #log.debug("songs: %s" % recv)
            except (musicpd.ConnectionError, BrokenPipeError) as e:
                self.log.fatal("get songs by album by albumartist failed: %s" % e)
                error = True
            if error:
                self.mpd_connect()
                return None

            for i in recv:
                if i == "":
                    continue
                #log.debug("Adding to cache albumartist / album / song: %s / %s / %s" % (artist, album, i))
                MPDDataCache.cache['Album Artists'][artist][album].append(i)

        return MPDDataCache.cache['Album Artists'][artist][album]

    def get_songs_by_album(self, album, mpd=None):
        """
        Finds songs by album.

        Args:
            album: name of the album
            mpd: Optional musicpd.MPDClient object. If not supplied, the object's mpd object will be used.

        Returns:
            list of dictionaries containing song data
        """
        if not mpd:
            mpd = self.mpd

        if not len(MPDDataCache.cache['Albums'][album]):
            error = False
            MPDDataCache.cache['Albums'][album] = []
            try:
                recv = self.mpd.find("album", album)
                #log.debug("songs: %s" % recv)
            except (musicpd.ConnectionError, BrokenPipeError) as e:
                self.log.fatal("get songs by album failed: %s" % e)
                error = True
            if error:
                self.mpd_connect()
                return None

            for i in recv:
                if i == "":
                    continue
                #log.debug("Adding to cache album / song: %s / %s" % (album, i))
                MPDDataCache.cache['Albums'][album].append(i)

        return MPDDataCache.cache['Albums'][album]

    def get_genres(self, mpd=None):
        """
        Gets the list of genres from mpd, enters artists into db_cache if needed

        Args:
            mpd: Optional musicpd.MPDClient object. If not supplied, the object's mpd object will be used.

        Returns:
            list of genres
        """
        if not mpd:
            mpd = self.mpd

        if not len(MPDDataCache.cache['Genres']):
            error = False
            try:
                recv = mpd.list("genre")
                #log.debug("genres: %s" % recv)
            except (musicpd.ConnectionError, BrokenPipeError) as e:
                self.log.fatal("get genres failed: %s" % e)
                error = True
            if error:
                self.mpd_connect()
                return None

            for i in recv:
                if i == "":
                    continue
                #log.debug("Adding to cache genres: %s" % i)
                MPDDataCache.cache['Genres'][i] = {}

        return MPDDataCache.cache['Genres'].keys()

    def get_albums_by_genre(self, genre, mpd=None):
        """
        Gets the list of albums by genre from mpd, enters albums into db_cache if needed

        Args:
            mpd: Optional musicpd.MPDClient object. If not supplied, the object's mpd object will be used.

        Returns:
            list of album names by an genre
        """
        if not mpd:
            mpd = self.mpd
        if not len(MPDDataCache.cache['Genres'][genre]):
            error = False
            try:
                recv = self.mpd.list("album", "genre", genre)
                #log.debug("albums: %s" % recv)
            except (musicpd.ConnectionError, BrokenPipeError) as e:
                self.log.fatal("get album by genre: %s" % e)
                error = True
            if error:
                self.mpd_connect()
                return None

            for i in recv:
                if i == "":
                    continue
                #self.log.debug("Adding to cache genres / album: %s / %s" % (genre, i))
                MPDDataCache.cache['Genres'][genre][i] = []

        return MPDDataCache.cache['Genres'][genre]

    def refresh_playback(self):
        """
        Updates playlist and playback if needed.
        Updates time info and progress bar.
        """
        #log.debug("refreshing playback")

        if self.mpd_status['state'] == "stop":
            self.window.current_time_label.set_text("Stopped")
            self.window.song_progress.set_value(0)
        elif self.mpd_status['state'] == "pause":
            self.window.current_time_label.set_text(pp_time(int(float(self.mpd_status['elapsed']))) + " / " + pp_time(
                int(float(self.mpd_status['duration']))) + " Paused")
        elif self.mpd_status['state'] == "play":
            ## Perform a full refresh after 5 secs
            since_last_update = time.time() - self.last_update_time
            if since_last_update >= 5:
                self.log.debug("full refresh")
                self.window.update_playback()
                self.last_update_time = time.time()
                self.last_update_offset = int(float(self.mpd_status['elapsed']))
            else:
                ## Increment time and progress bar
                current_offset = self.last_update_offset + int(since_last_update)
                self.window.song_progress.set_value(current_offset)
                self.window.current_time_label.set_text(
                    pp_time(current_offset) + " / " + pp_time(int(float(self.mpd_status['duration']))) + " Playing")
        else:
            self.log.info("unknown state: %s" % self.mpd_status['state'])
        return True

    def get_files_list(self, path=""):
        """
        """
        error = False
        try:
            ## Make sure cache paths exist
            cache = None
            """
            if len(path):
                path_list = re.split(r'/', path)
                log.debug("path list: %s" % path_list)
                cache = self.db_cache['Files']
                for p in path_list:
                    if p not in cache:
                        log.debug("caching file: %s" % p)
                        cache[p] = {}
                    cache = cache[p]
            log.debug("file cache: %s" % cache)

            if cache:
                rows = []
                for f in cache:
                    rows.append(f)
            """

            files = self.mpd.lsinfo(path)
            #log.debug("files from mpd: %s" % files)
            rows = []
            for f in files:
                #log.debug("files list: %s" % f)
                if 'directory' in f:
                    dirname = os.path.basename(f['directory'])
                    rows.append(
                        {'type': 'directory', 'value': dirname, 'data': {'name': dirname, 'dir': f['directory']}})
                elif 'file' in f:
                    filename = os.path.basename(f['file'])
                    finfo = None
                    #if filename in cache:
                    #    finfo = cache[filename]
                    #else:
                    finfo = self.mpd.lsinfo(f['file'])[0]
                    if not finfo:
                        finfo = {'file': f['file']}
                    #log.debug("file info: %s %s" % (f['file'], finfo))
                    rows.append({'type': 'file', 'value': filename, 'data': finfo})
                    #cache[filename] = finfo
                    #log.debug("db cache files: %s" % self.db_cache['Files'])
            return rows

        except (musicpd.ConnectionError, BrokenPipeError) as e:
            self.log.error("listing files: %s" % e)
            error = True
        if error:
            self.mpd_connect()

class MPDDataCache():
    cache = {
        'Album Artists': {},
        'Artists': {},
        'Albums': {},
        'Files': {},
        'Genres': {},
        'Songs': {},
    }

    @staticmethod
    def clear():
        for k in MPDDataCache.cache.keys():
            MPDDataCache.cache[k] = {}

class MPDIdleClient():
    do_update_playlist = False  ## Set when mpd has a playlist change event
    do_update_playback = False  ## Set when mpd has a player change event
    do_update_database = False  ## Set when mpd has a database change event
    def __init__(self, host=None, port=None, app=None):
        self.log = Defaults.get_logger()
        if not host or not port or not app:
            err_msg = "host, port or app  not defined"
            self.log.error(err_msg)
            raise ValueError(err_msg)
        self.app = app
        try:
            self.mpd = musicpd.MPDClient()
            self.mpd.connect(host, port)
        except Exception as e:
            self.log.error("could not connect to host %s at port %d: %s" % (host, port, e))
            raise e

        self.run_idle = True
        self.spawn_idle_thread()

    def idle_thread(self):
        """
        Function that runs in the idle thread created by spawn_idle_thread().
        Listens for changes from MPD, using the idle command.
        Updates UI to idle()
        """
        while self.run_idle:
            error = False
            reconnect = False
            try:
                self.mpd.send_idle()
                changes = self.mpd.fetch_idle()
            except (musicpd.ConnectionError, BrokenPipeError) as e:
                self.log.error("idle connection failed: %s" % e)
                reconnect = True
                error = True
            except Exception as e:
                self.log.error("idle failed: %s" % e)
                error = True
            if reconnect:
                try:
                    self.mpd.connect()
                except (musicpd.ConnectionError, BrokenPipeError) as e:
                    self.log.error("idle failed reconnect: %s" % e)
                    time.sleep(Defaults.idle_sleep_retry_connect)
                    error = True
            if error:
                self.log.error("idle thread connection error(s)")
                continue
            else:
                self.log.debug("changes: %s" % changes)
                for c in changes:
                    if c == "playlist":
                        self.log.debug("playlist changes")
                        self.do_update_playlist = True
                        self.app.window.update_playlist()
                    elif c == "player":
                        self.log.debug("player changes")
                        self.do_update_playback = True
                        self.app.window.update_playback()
                    elif c == "database":
                        self.log.debug("database changes")
                        self.do_update_database = True
                    elif c == "outputs":
                        None
                    elif c == "mixer":
                        None
                    else:
                        self.log.info("Unhandled change: %s" % c)

    def spawn_idle_thread(self):
        """
        Creates and starts the idle thread that listens for change events from MPD.
        """
        try:
            idle_thread = threading.Thread(target=self.idle_thread, args=(), name="idle_update", daemon=True)
            #idle_thread.daemon = True
            idle_thread.start()
        except Exception as e:
            self.log.fatal("Could not spawn idle thread: %s" % e)
            raise e
        return True

if __name__ == "__main__":
    ## set signal handlers
    signal.signal(signal.SIGINT, signal_exit)
    signal.signal(signal.SIGTERM, signal_exit)

    ## parse args
    arg_parser = argparse.ArgumentParser(description="MPD Frontend", formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    arg_parser.add_argument("-v", "--verbose", action='store_true', help="Turn on verbose output.")
    arg_parser.add_argument("-H", "--host", action='store', help="Remote host name or IP address.")
    arg_parser.add_argument("-p", "--port", type=int, action='store', help="Remote TCP port number.")
    arg_parser.add_argument("-s", "--css", action='store', help="CSS file for the Gtk App.")
    arg_parser.add_argument("-c", "--config", default=Defaults.config_file, action='store', help="Config file.")
    args = arg_parser.parse_args()

    Defaults.init_logger()
    if args.verbose:
        Defaults.get_logger().setLevel(logging.DEBUG)

    ## get configs and create main window
    config = configparser.ConfigParser()

    if not os.path.exists(args.config):  ## verify config file exists
        Defaults.get_logger().critical("no config file %s\n" % args.config)
        sys.exit(1)
    config.read(args.config)

    try:
        app = MPDFrontApp(config=config, css_file=args.css, application_id=Defaults.application_id)
    except Exception as e:
        Defaults.get_logger().critical("could not create application: %s" % e)
        sys.exit(3)

    app.run(None)
    sys.exit(0)
